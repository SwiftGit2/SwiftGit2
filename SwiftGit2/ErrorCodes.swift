import Foundation
import Clibgit2

/// The underlying error generated by libgit2
public struct Libgit2Error: Error, CustomStringConvertible, Equatable {
	public let errorCode: git_error_code

	/// The libgit2 function that produced the error
	public let source: Libgit2Method

	/// The type of underlying error
	public let errorType: Libgit2ErrorType

	public let errorMessage: String?

	public var description: String {
		"\(errorMessage ?? errorCode.description), type: \(errorType), source: \(source)"
	}

	internal init(errorCode: Int32, source: Libgit2Method) {
		self.errorCode = git_error_code(rawValue: errorCode)
		self.source = source
		let (type, message) = Libgit2Error.getLatestType()
		self.errorType = type
		self.errorMessage = message
	}

	internal static func getLatestType() -> (type: Libgit2ErrorType, errorMessage: String?) {
		guard let lastErrorPointer = git_error_last() else {
			return (type: .none, errorMessage: nil)
		}
		let errorType = git_error_t(rawValue: UInt32(lastErrorPointer.pointee.klass))
		let type = Libgit2ErrorType(rawValue: errorType)
		let errorMessage = String(validatingUTF8: lastErrorPointer.pointee.message)
		return (type: type, errorMessage: errorMessage)
	}
}

/// Source Libit2 method where an error was reported
public enum Libgit2Method {
	case git_repository_init
	case git_signature_new
	case git_repository_open
	case git_clone
	case git_object_lookup
	case git_remote_list
	case git_remote_lookup
	case git_remote_fetch
	case git_reference_list
	case git_reference_lookup
	case git_repository_head
	case git_repository_set_head
	case git_checkout_head
	case git_repository_index
	case git_index_add_all
	case git_index_write
	case git_tree_lookup
	case git_commit_lookup
	case git_commit_create
	case git_index_write_tree
	case git_reference_name_to_id
	case git_diff_merge
	case git_diff_tree_to_tree
	case git_status_init_options
	case git_status_list_new
	case git_repository_open_ext
	case git_revwalk_next
}

extension git_error_code: CustomStringConvertible {
	public var description: String {
		switch self {
		case GIT_OK:
			return "No error"
		case GIT_ERROR:
			return "Generic error"
		case GIT_ENOTFOUND:
			return "Requested object could not be found"
		case GIT_EEXISTS:
			return "Object exists preventing operation"
		case GIT_EAMBIGUOUS:
			return "More than one object matches"
		case GIT_EBUFS:
			return "Output buffer too short to hold data"
		case GIT_EUSER:
			return "A special error that is never generated by libgit2"
		case GIT_EBAREREPO:
			return "Operation not allowed on bare repository"
		case GIT_EUNBORNBRANCH:
			return "HEAD refers to branch with no commits"
		case GIT_EUNMERGED:
			return "Merge in progress prevented operation"
		case GIT_ENONFASTFORWARD:
			return "Reference was not fast-forwardable"
		case GIT_EINVALIDSPEC:
			return "Name/ref spec was not in a valid format"
		case GIT_ECONFLICT:
			return "Checkout conflicts prevented operation"
		case GIT_ELOCKED:
			return "Lock file prevented operation"
		case GIT_EMODIFIED:
			return "Reference value does not match expected"
		case GIT_EAUTH:
			return "Authentication error"
		case GIT_ECERTIFICATE:
			return "Server certificate is invalid"
		case GIT_EAPPLIED:
			return "Patch/merge has already been applied"
		case GIT_EPEEL:
			return "The requested peel operation is not possible"
		case GIT_EEOF:
			return "Unexpected EOF"
		case GIT_EINVALID:
			return "Invalid operation or input"
		case GIT_EUNCOMMITTED:
			return "Uncommitted changes in index prevented operation"
		case GIT_EDIRECTORY:
			return "The operation is not valid for a directory"
		case GIT_EMERGECONFLICT:
			return "A merge conflict exists and cannot continue"
		case GIT_PASSTHROUGH:
			return "Internal only"
		case GIT_ITEROVER:
			return "Signals end of iteration with iterator"
		case GIT_RETRY:
			return "Internal only"
		case GIT_EMISMATCH:
			return "Hashsum mismatch in object"
		default:
			return "Unknown Error Code: \(self)"
		}
	}
}

public enum Libgit2ErrorType {
	case none
	case noMemory
	case os
	case invalid
	case reference
	case zlib
	case repository
	case config
	case regex
	case odb
	case index
	case object
	case net
	case tag
	case tree
	case indexer
	case ssl
	case submodule
	case thread
	case stash
	case checkout
	case fetchHead
	case merge
	case ssh
	case filter
	case revert
	case callback
	case cherryPick
	case describe
	case rebase
	case fileSystem
	case patch
	case workTree
	case sha1
	case http
	case `internal`
}

extension Libgit2ErrorType: RawRepresentable {
	public init(rawValue: git_error_t) {
		switch rawValue {
		case GIT_ERROR_NOMEMORY:
			self = .noMemory
		case GIT_ERROR_OS:
			self = .os
		case GIT_ERROR_INVALID:
			self = .invalid
		case GIT_ERROR_REFERENCE:
			self = .reference
		case GIT_ERROR_ZLIB:
			self = .zlib
		case GIT_ERROR_REPOSITORY:
			self = .repository
		case GIT_ERROR_CONFIG:
			self = .config
		case GIT_ERROR_REGEX:
			self = .regex
		case GIT_ERROR_ODB:
			self = .odb
		case GIT_ERROR_INDEX:
			self = .index
		case GIT_ERROR_OBJECT:
			self = .object
		case GIT_ERROR_NET:
			self = .net
		case GIT_ERROR_TAG:
			self = .tag
		case GIT_ERROR_TREE:
			self = .tree
		case GIT_ERROR_INDEXER:
			self = .indexer
		case GIT_ERROR_SSL:
			self = .ssl
		case GIT_ERROR_SUBMODULE:
			self = .submodule
		case GIT_ERROR_THREAD:
			self = .thread
		case GIT_ERROR_STASH:
			self = .stash
		case GIT_ERROR_CHECKOUT:
			self = .checkout
		case GIT_ERROR_FETCHHEAD:
			self = .fetchHead
		case GIT_ERROR_MERGE:
			self = .merge
		case GIT_ERROR_SSH:
			self = .ssh
		case GIT_ERROR_FILTER:
			self = .filter
		case GIT_ERROR_REVERT:
			self = .revert
		case GIT_ERROR_CALLBACK:
			self = .callback
		case GIT_ERROR_CHERRYPICK:
			self = .cherryPick
		case GIT_ERROR_DESCRIBE:
			self = .describe
		case GIT_ERROR_REBASE:
			self = .rebase
		case GIT_ERROR_FILESYSTEM:
			self = .fileSystem
		case GIT_ERROR_PATCH:
			self = .patch
		case GIT_ERROR_WORKTREE:
			self = .workTree
		case GIT_ERROR_SHA1:
			self = .sha1
		case GIT_ERROR_HTTP:
			self = .http
		case GIT_ERROR_INTERNAL:
			self = .internal
		default:
			self = .none
		}
	}

	public var rawValue: git_error_t {
		switch self {
		case .none:
			return GIT_ERROR_NONE
		case .noMemory:
			return GIT_ERROR_NOMEMORY
		case .os:
			return GIT_ERROR_OS
		case .invalid:
			return GIT_ERROR_INVALID
		case .reference:
			return GIT_ERROR_REFERENCE
		case .zlib:
			return GIT_ERROR_ZLIB
		case .repository:
			return GIT_ERROR_REPOSITORY
		case .config:
			return GIT_ERROR_CONFIG
		case .regex:
			return GIT_ERROR_REGEX
		case .odb:
			return GIT_ERROR_ODB
		case .index:
			return GIT_ERROR_INDEX
		case .object:
			return GIT_ERROR_OBJECT
		case .net:
			return GIT_ERROR_NET
		case .tag:
			return GIT_ERROR_TAG
		case .tree:
			return GIT_ERROR_TREE
		case .indexer:
			return GIT_ERROR_INDEXER
		case .ssl:
			return GIT_ERROR_SSL
		case .submodule:
			return GIT_ERROR_SUBMODULE
		case .thread:
			return GIT_ERROR_THREAD
		case .stash:
			return GIT_ERROR_STASH
		case .checkout:
			return GIT_ERROR_CHECKOUT
		case .fetchHead:
			return GIT_ERROR_FETCHHEAD
		case .merge:
			return GIT_ERROR_MERGE
		case .ssh:
			return GIT_ERROR_SSH
		case .filter:
			return GIT_ERROR_FILTER
		case .revert:
			return GIT_ERROR_REVERT
		case .callback:
			return GIT_ERROR_CALLBACK
		case .cherryPick:
			return GIT_ERROR_CHERRYPICK
		case .describe:
			return GIT_ERROR_DESCRIBE
		case .rebase:
			return GIT_ERROR_REBASE
		case .fileSystem:
			return GIT_ERROR_FILESYSTEM
		case .patch:
			return GIT_ERROR_PATCH
		case .workTree:
			return GIT_ERROR_WORKTREE
		case .sha1:
			return GIT_ERROR_SHA1
		case .http:
			return GIT_ERROR_HTTP
		case .internal:
			return GIT_ERROR_INTERNAL
		}
	}
}
